# To improve query performance, we strongly suggest adding indexes to any field that you plan to filter or sort by
# Add the `@index` or `@index(unique: true)` annotation after any non-key field
# https://academy.subquery.network/build/graphql.html#indexing-by-non-primary-key-field

type Block @entity {
  id: ID! # The block hash
  height: BigInt!
}

type Transaction @entity {
  id: ID!
  blockHeight: BigInt!
  timestamp: String!
}

type ExecuteEvent @entity {
  id: ID!
  blockHeight: BigInt!
  txHash: String!
}

type MarketplaceListing @entity {
  id: ID!
  owner: String!
  denom: String!
  amount: BigInt!
  pricePerCreditAmount: BigInt!
  pricePerCreditDenom: String!
}

type CreateListingWasmEvent @entity {
  id: ID!
  listingOwner: String!
  denom: String!
  numberOfCredits: BigInt!
  pricePerCreditAmount: BigInt!
  pricePerCreditDenom: String!
}

type UpdateListingWasmEvent @entity {
  id: ID!
  listingOwner: String!
  denom: String!
  numberOfCredits: BigInt!
  pricePerCreditAmount: BigInt!
  pricePerCreditDenom: String!
}

type CancelListingWasmEvent @entity {
  id: ID!
  listingOwner: String!
  denom: String!
}

type BuyCreditsWasmEvent @entity {
  id: ID!
  listingOwner: String!
  denom: String!
  buyer: String!
  numberOfCreditsBought: BigInt!
  totalPriceAmount: BigInt!
  totalPriceDenom: String!
}

type CreateListing @entity {
  id: ID!
  owner: String!
  denom: String!
  amount: BigInt!
  pricePerCredit: String!
}

type CreditCollection @entity {
  id: ID!
  denom: String! @index(unique: true)
  projectId: Int! @index(unique: true)
  activeAmount: BigInt!
  retiredAmount: BigInt!
  creditType: String!
  metadataUris: [MetadataUri!] @derivedFrom(field: "creditCollection")
  creditData: [CreditData!] @derivedFrom(field: "creditCollection")
}

type CreditData @entity {
  id: ID!
  issuanceDate: String!
  creditType: String!
  amount: BigInt!
  aggregationLatitude: String!
  aggregationLongitude: String!
  eventData: [EventData!] @derivedFrom(field: "creditData")
  mediaFiles: [MediaFile!] @derivedFrom(field: "creditData")
  binaryFiles: [BinaryFile!] @derivedFrom(field: "creditData")
  applicant_data: ApplicantData! @derivedFrom(field: "creditData")
  creditCollection: CreditCollection!
}

type WebReference @entity {
  id: ID!
  applicantData: ApplicantData!
  url: String!
}

type ApplicantData @entity {
  id: ID!
  name: String!
  description: String!
  webReferences: [WebReference!]! @derivedFrom(field: "applicantData")
  creditData: CreditData!
}

type MediaFile @entity {
  id: ID!
  name: String!
  url: String!
  creditData: CreditData!
}

type BinaryFile @entity {
  id: ID!
  name: String!
  url: String!
  creditData: CreditData!
}

type EventData @entity {
  id: ID!
  latitude: String!
  longitude: String!
  amount: String!
  magnitude: String!
  material: [MaterialData!]! @derivedFrom(field: "eventData")
  registrationDate: String!
  creditData: CreditData!
}

type MaterialData @entity {
  id: ID!
  key: String!
  value: String!
  eventData: EventData!
}

type MetadataUri @entity {
  id: ID!
  creditCollection: CreditCollection!
  url: String! @index(unique: true)
}

type Message @entity {
  id: ID!
  blockHeight: BigInt!
  txHash: String!
}
